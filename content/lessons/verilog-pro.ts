export const verilogProLessons = [
    {
        id: "v-pro-1",
        title: "Pro 1.1: Silicon Lexical Standards",
        theory: "Lexical conventions define the syntax rules of Verilog, from identifiers to whitespace.",
        detailedDescription: `In hardware design, precision is everything. **Lexical Conventions** are the legal grammar of silicon. Just as a small typo in a legal contract can cost millions, a single misplaced character in Verilog can lead to un-synthesizable hardware or "X" generation in simulation.

### Key Rules of Engagement:
- **Case Sensitivity**: Verilog is case-sensitive. \`wire DATA\` and \`wire data\` are two distinct physical signals. Use this to differentiate between clock domains (e.g., \`clk_io\` vs \`CLK_IO\`).
- **Whitespace**: Blanks, tabs, and newlines are ignored by the compiler but essential for your "code-review" peers.
- **Identifiers**: Signal names must start with a letter or underscore. 
  - *Standard*: \`reg data_ready;\`
  - *Advanced (Escaped)*: \`reg \\net_123 ;\`. Avoid these unless generated by a CAD tool.

### Comments for Posterity:
Always document 'Magic Numbers'.
- \`// Single line: Logic for the arbiter\`
- \`/* Multi-line: 
     This block implements the 
     Round Robin algorithm */\``,
        realWorldExample: "Industrial Naming Conventions: In professional RTL groups (Intel/AMD), signals often have prefixes: 'i_' for inputs, 'o_' for outputs, and 'r_' for registers. This 'Lexical Standard' prevents electrical contention bugs during chip integration.",
        imagePath: "/assets/lexical_rules.png",
        expectedOutput: "Valid Lexical Syntax Check",
        code: `module lexical_demo(
    input i_data_in,
    output reg o_data_out
);
    // This is a professional-grade comment
    always @(*) begin
        o_data_out = i_data_in;
    end
endmodule`,
        testbench: `module tb;
    reg i_data_in; wire o_data_out;
    lexical_demo dut(i_data_in, o_data_out);
    initial begin
        i_data_in = 1; #10;
        $display("Data out is %b", o_data_out);
    end
endmodule`,
        track: "verilog",
        module: 1  // Integrated into Module 1
    },
    {
        id: "v-pro-2",
        title: "Pro 1.2: Hardware Data Storage (Nets vs Regs)",
        theory: "Understanding the physical difference between 'wire' and 'reg' is fundamental to RTL.",
        detailedDescription: `In a CPU, data is either "flying through" or "sitting still". 

### 1. Nets (wire): The Copper Trace
Net types represent physical connections between hardware components. They **do not store values**. They simply transmit electrical charge.
- **Usage**: Use \`wire\` for continuous assignments (\`assign\`) and connecting module ports.

### 2. Variables (reg / logic): The Silicon Memory
Variable types can hold a state. They represent the output of a storage element or a procedural block.
- **Usage**: Use \`reg\` for bits set inside \`always\` or \`initial\` blocks. 
- **The Logic Type**: In SystemVerilog, \`logic\` replaces both \`wire\` and \`reg\` in 90% of cases, simplifying design rules.

### 4-State Value System:
Hardware is not just 0 or 1.
- **0 & 1**: Valid logic states.
- **X (Unknown)**: Potential contention or uninitialized state. The "Nightmare" of verification.
- **Z (High Impedance)**: Disconnected state. Used in Tri-state buffers for shared buses (e.g., I2C, USB).`,
        realWorldExample: "The USB Shared Bus: When multiple devices share a single wire, they must use the 'High-Impedance (Z)' state to 'let go' of the wire so another device can talk. Without this data-type mastery, you'd have a short circuit!",
        imagePath: "/assets/data_types_silicon.png",
        expectedOutput: "Correct 4-state logic propagation",
        code: `module bridge_logic(
    input a, b,
    output wire y_tri
);
    assign y_tri = (a) ? b : 1'bz; // Drive 'b' if 'a' is high, else let go
endmodule`,
        testbench: `module tb;
    reg a, b; wire y_tri;
    bridge_logic dut(a, b, y_tri);
    initial begin
        a=1; b=0; #10;
        a=0; #10; // Result should be Hi-Z
    end
endmodule`,
        track: "verilog",
        module: 1  // Integrated into Module 1 - Fundamentals
    },
    {
        id: "v-pro-3",
        title: "Pro 1.3: Vector Systems (The Silicon Highway)",
        theory: "Vectors allow us to group multiple signals into a single 'bus' for wide datapath processing.",
        detailedDescription: `In a modern GPU, data doesn't move 1 bit at a time. It moves in massive "Vectors" of 256, 512, or even 1024 bits.

### Vector Syntax:
- **Big-Endian (Standard)**: \`wire [31:0] data_bus;\` (Most Significant Bit is 31).
- **Little-Endian**: \`wire [0:31] addr_bus;\`. Use this carefully; it's rare in modern RTL but common in legacy systems.

### Part-Select Power:
You can slice a vector like a piece of cake.
- \`assign byte_0 = data_bus[7:0];\`
- \`assign byte_1 = data_bus[15:8];\`

### The Multi-Lane Logic:
When you perform an operation on a vector, Verilog performs it "Bit-Wise" across all lanes simultaneously. This is the secret to parallel computing!`,
        realWorldExample: "PCIe Lane Scaling: A PCIe x16 slot uses a 16-lane vector to move data. If one lane fails, the hardware 're-vectors' the data to a narrower x8 width. Understanding vector slicing is how you implement this 'Auto-Negotiation' logic.",
        imagePath: "/assets/vector_slicing.png",
        expectedOutput: "Successful Vector Slicing & Extraction",
        code: `module bus_slicer(
    input [15:0] i_wide_bus,
    output [7:0] o_low_byte,
    output [7:0] o_high_byte
);
    // Slice the silicon highway
    assign o_low_byte  = i_wide_bus[7:0];
    assign o_high_byte = i_wide_bus[15:8];
endmodule`,
        testbench: `module tb;
    reg [15:0] i_wide_bus; wire [7:0] low, high;
    bus_slicer dut(i_wide_bus, low, high);
    initial begin
        i_wide_bus = 16'hABCD; #10;
        $display("Low: %h (Expect CD)", low);
        $display("High: %h (Expect AB)", high);
    end
endmodule`,
        track: "verilog",
        module: 4
    },
    {
        id: "v-pro-4",
        title: "Pro 1.4: Numerical Literacy in Hardware",
        theory: "Hardware processes numbers in various bases (Binary, Hex, Decimal). Accuracy is non-negotiable.",
        detailedDescription: `Silicon doesn't understand "10". It understands voltage levels. As an engineer, you must translate human numbers into hardware literals.

### Literals Format: \`<size>'<base><value>\`
- **Binary (\`'b\`)**: \`4'b1010\`. Perfect for bit-masking.
- **Hexadecimal (\`'h\`)**: \`8'hFF\`. The industry standard for compact memory addressing.
- **Decimal (\`'d\`)**: \`10'd1024\`. Least common in low-level RTL, used for counters.

### The 'Sized' vs 'Unsized' Trap:
- \`assign y = 1;\` // UNSIZED - Compiler defaults to 32-bits! This creates "Bit-Width Mismatch" warnings.
- \`assign y = 1'b1;\` // SIZED - Professional, explicit, and lint-clean.

### Signed Numbers (\`signed\`):
By default, Verilog is Unsigned. For DSP (Digital Signal Processing), use \`wire signed [7:0]\` to enable 2's complement math automatically.`,
        realWorldExample: "The GPS Altitude Error: A famous bug occurred when an unsized negative number was assigned to an unsigned variable, causing a drone to think it was at 65,000 feet instead of -1 meter. Proper 'Numerical Literacy' prevents structural failure.",
        imagePath: "/assets/hardware_literals.png",
        expectedOutput: "Base conversion & Literal verification",
        code: `module numeric_converter(
    output [7:0] o_hex,
    output [7:0] o_bin,
    output [7:0] o_dec
);
    assign o_hex = 8'hA5;   // 165
    assign o_bin = 8'b10100101; 
    assign o_dec = 8'd165;
endmodule`,
        testbench: `module tb;
    wire [7:0] h, b, d;
    numeric_converter dut(h, b, d);
    initial begin
        #10;
        if (h == b && b == d) $display("NUMERICS MATCH!");
        else $display("ERROR: Literal Mismatch");
    end
endmodule`,
        track: "verilog",
        module: 4
    },
    {
        id: "v-pro-5",
        title: "Pro 1.5: Hardware Operators (The Tools of Trade)",
        theory: "Operators are the functional engines that transform input data into actionable outputs.",
        detailedDescription: `In Verilog, operators are divided into categories based on how they affect the bits.

### 1. Bitwise Operators (The Surgical Blade):
These operate bit-by-bit. If you AND two 8-bit buses, Verilog performs 8 independent AND operations.
- \`&\` (AND), \`|\` (OR), \`^\` (XOR), \`~\` (NOT).

### 2. Reduction Operators (The Compactor):
These take a multi-bit vector and reduce it to a **1-bit result**.
- \`&data\`: Returns 1 if ALL bits are 1.
- \`^data\`: Returns 1 if there is an ODD number of 1s (Standard Parity Check).

### 3. Concatenation & Replication (The Assembly Line):
These allows you to "glue" signals together.
- **Concatenation**: \`{byte_h, byte_l}\` creates a 16-bit word.
- **Replication**: \`{4{2'b10}}\` creates \`8'b10101010\`.`,
        realWorldExample: "Network Packet Parity: When a packet arrives over Ethernet, the hardware uses a **Reduction XOR (\^)** operator to quickly check if the data was corrupted during flight. It's a 1-nanosecond sanity check that keeps the internet reliable.",
        imagePath: "/assets/hw_operators.png",
        expectedOutput: "Reduction & Concatenation verification",
        code: `module networking_utils(
    input [7:0] i_payload,
    output o_parity,
    output [15:0] o_packet
);
    // Reduction XOR for parity
    assign o_parity = ^i_payload;
    
    // Concatenate header (8'hAA) with payload
    assign o_packet = {8'hAA, i_payload};
endmodule`,
        testbench: `module tb;
    reg [7:0] i_payload; wire p; wire [15:0] pkt;
    networking_utils dut(i_payload, p, pkt);
    initial begin
        i_payload = 8'b11001100; #10;
        $display("Parity: %b (Expect 0)", p);
        $display("Packet: %h (Expect AA CC)", pkt);
    end
endmodule`,
        track: "verilog",
        module: 1  // Integrated into Module 1 - Operators
    },
    {
        id: "v-pro-6",
        title: "Pro 1.6: Behavioral Modeling (The Software-Hardware Bridge)",
        theory: "Behavioral modeling allows you to describe circuit functionality at a high level of abstraction.",
        detailedDescription: `As designs scale into billions of transistors, gate-level modeling becomes impossible. **Behavioral Modeling** is the high-level language of modern VLSI. It allows you to describe *intent* over *implementation*.

### 1. The Procedural Mindset:
Behavioral code lives inside **Procedural Blocks** (\`initial\` and \`always\`). Unlike continuous assignments, these statements execute sequentially.

### 2. Sensitivity Lists (The Trigger):
The \`always @(...)\` block is dormant until a signal in its sensitivity list changes.
- **Combinational**: \`always @(*)\` - Triggers on any input change.
- **Sequential**: \`always @(posedge clk)\` - Triggers only on the rising clock edge.

### 3. High-Level Constructs:
You can use \`if-else\`, \`case\`, and \`loops\`, making hardware design feel like software programming (but with physical consequences).`,
        realWorldExample: "SSD Wear-Leveling: An SSD controller must decide which physical block to write data to based on how many times each block has been used. Implementing this as individual gates would be a nightmare; using a behavioral 'always' block with a 'case' statement allows for complex logic to be synthesized into efficient silicon in seconds.",
        imagePath: "/assets/behavioral_modeling.png",
        expectedOutput: "Behavioral logic execution & trigger check",
        code: `module behavioral_mux(
    input a, b, sel,
    output reg y
);
    // Behavioral 'if-else' bridge
    always @(*) begin
        if (sel) 
            y = b;
        else 
            y = a;
    end
endmodule`,
        testbench: `module tb;
    reg a, b, sel; wire y;
    behavioral_mux dut(a, b, sel, y);
    initial begin
        a=1; b=0; sel=0; #10;
        sel=1; #10;
        $display("Sel=0: y=%b | Sel=1: y=%b", a, y);
    end
endmodule`,
        track: "verilog",
        module: 2  // Integrated into Module 2 - Behavioral Logic
    },
    {
        id: "v-pro-7",
        title: "Pro 1.7: Procedural Control (The Logic Traffic Controller)",
        theory: "Procedural assignments control the flow of data within a design, managing states and transitions.",
        detailedDescription: `Inside a block, there are two ways to move data. Choosing the wrong one is the #1 cause of bugs in professional hardware design.

### 1. Blocking Assignments (=): The 'Now' Logic
These happen immediately. The next line of code won't run until the current one is finished.
- **Analogy**: Like a line of people at a checkout. Person A finishes, then Person B starts.
- **Best For**: Combinational logic.

### 2. Non-Blocking Assignments (<=): The 'Later' Logic
These happen at the end of the time step. All assignments are "scheduled" and then updated simultaneously.
- **Analogy**: Like a synchronized dance. Everyone moves to their next position at the exact same beat.
- **Best For**: Sequential logic (Flip-flops).

### The Golden Rule of RTL:
- ALWAYS use \`=\` for combinational (\`always @(*)\`).
- ALWAYS use \`<= \` for sequential (\`always @(posedge clk)\`).`,
        realWorldExample: "Camera Image Capture: In a digital camera sensor, all pixels must be sampled at the exact same moment to avoid 'Rolling Shutter' distortion. Hardware designers use **Non-Blocking Assignments (<=)** to ensure the entire image array updates on the same clock edge.",
        imagePath: "/assets/procedural_assignments.png",
        expectedOutput: "Blocking vs Non-blocking verification",
        code: `module shift_reg_demo(
    input clk, d,
    output reg q1, q2
);
    // Sequential 'Synchronized Dance'
    always @(posedge clk) begin
        q1 <= d;
        q2 <= q1; // q2 gets 'old' q1, creating a shift
    end
endmodule`,
        testbench: `module tb;
    reg clk, d; wire q1, q2;
    shift_reg_demo dut(clk, d, q1, q2);
    initial begin
        clk=0; d=1; #10; clk=1; #10;
        clk=0; d=0; #10; clk=1; #10;
        $display("Q1=%b, Q2=%b (Shift Register behavior)", q1, q2);
    end
endmodule`,
    },
    {
        id: "v-pro-8",
        title: "Pro 1.8: Digital Fundamentals (The Speed Limit)",
        theory: "Setup and Hold times define the physical timing window required for a register to capture data reliably.",
        detailedDescription: `In a perfect world, hardware is instantaneous. In reality, data has mass and electricity takes time to move.

### 1. Setup Time ($t_{su}$):
The data must be stable **before** the clock edge. Think of it like a train station; you must be on the platform before the doors close.

### 2. Hold Time ($t_h$):
The data must remain stable **after** the clock edge. You can't jump off the train until it has fully started moving.

### 3. Timing Violations:
If you violate these, the flip-flop enters an unstable state (Metastability), and your chip will crash or produce random data.`,
        realWorldExample: "Overclocking a CPU: When gamers 'overclock' their PC, they are pushing the clock period to be shorter than the **Setup Time ($t_{su}$)** required for the signals to reach their destination. This leads to the 'Blue Screen of Death' as logic bits begin to fail their delivery window.",
        imagePath: "/assets/setup_hold_timing.png",
        expectedOutput: "Timing Window Verification",
        code: `module setup_hold_checker(
    input clk, d,
    output reg q
);
    // Physically, 'd' must arrive 2ns before 'clk'
    always @(posedge clk) begin
        q <= d;
    end
endmodule`,
        testbench: `// Standalone timing logic`,
        track: "verilog",
        module: 4
    },
    {
        id: "v-pro-9",
        title: "Pro 1.9: Metastability (Ghost in the Machine)",
        theory: "Metastability occurs when a signal is captured while it is transitioning, leading to an unpredictable state.",
        detailedDescription: `What happens if data changes exactly on the clock edge? The transistor gets 'stuck' between 0 and 1. 

### 1. The Coin Analogy:
If you flip a coin, it usually lands Heads or Tails. Metastability is like the coin landing **on its edge**. It stays there for an unpredictable amount of time before falling.

### 2. MTBF (Mean Time Between Failures):
We cannot prevent metastability, but we can reduce its probability using **Synchronizers**.

### 3. The 2-Stage Synchronizer:
By passing the signal through two flip-flops in a row, we give the 'edge-standing' coin two chances to fall over before the rest of the chip sees the result.`,
        realWorldExample: "Button Press Sync: When you press a button on a microwave, that signal is 'Asynchronous' to the internal 10MHz clock. Without a **2-Stage Synchronizer**, the microwave controller might enter a metastable state and turn on the heating element at the wrong power level. Engineering for metastability keeps consumer electronics safe.",
        imagePath: "/assets/metastability_sync.png",
        expectedOutput: "Synchronizer behavioral check",
        code: `module sync_2stage(
    input clk, async_in,
    output reg sync_out
);
    reg q1;
    // The 'Double-Shield' against metastability
    always @(posedge clk) begin
        q1 <= async_in;
        sync_out <= q1;
    end
endmodule`,
        testbench: `// Standalone sync logic`,
        track: "verilog",
        module: 4
    }
];
